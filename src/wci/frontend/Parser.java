package wci.frontend;

import wci.intermediate.ICode.*;
import wci.intermediate.SymTab.*;
import wci.message.Message;
import wci.message.MessageHandler;
import wci.message.MessageListener;
import wci.message.MessageProducer;

/**
 * <h1>Parser</h1>
 * <p>A language-independent framework class. This abstract parser class will be implemented by language-specific subclasses</p>
 * <p>An abstract class in Java is simply a class that can provide generic functionality to a large amount of subclasses.
 * the sub-classes that take from it</p>
 */

public abstract class Parser implements MessageProducer {

    // protected in Java means that the field or method is only accessible by classes defined within the same package or by any subclasses defined in other packages.
    // packages provide this behavior by default, i.e. package fields or methods can only be accessed by other classes within the package.
    // private is accessible only from within the class
    // public methods serve as gateways across packages, i.e. we want it to be accessed from outside the package
    protected static SymTab symTab; // generated symbol tab
    protected static MessageHandler messageHandler;

    // Because there is only one symbol table in front end, we can implement here as a class field.
    // Static block will initialize it once before any Parser objects are created (i.e. the first time the class is loaded into memory)
    static {
        symTab = null;
        messageHandler = new MessageHandler();
    }

    protected Scanner scanner; // scanner used with this parser
    protected ICode iCode; // intermediate code generated by this parser

    /**
     * Constructor
     * @param scanner the scanner to be used with this parser
     */
    protected Parser(Scanner scanner){
        this.scanner = scanner;
        this.iCode = null;
    }

    /**
     * Parse a source program and generate the intermediate code and the symbol table. To be implemented by a language-specific
     * parser subclass.
     * @throws Exception if an error occurred.
     * Note that the abstract keyword is necessary to indicate to Java that we are simply defining a method in the superclass, but they will
     * implemented by the subclasses
     */
    public abstract void parse()
        throws Exception;

    /**
     * Return the number of syntax errors found by the parser. To be implemented by a language-specific parser subclass.
     * @return the error count.
     */
    public abstract int getErrorCount();

    /**
     * Call the scanner's currentToken() method.
     * @return the current token.
     */
    public Token currenttoken() {
        return scanner.currentToken();
    }

    /**
     * Call the scanner's nextToken() method.
     * @return the next token.
     * @throws Exception if an error occured.
     */
    public Token nextToken()
        throws Exception {
            return scanner.nextToken();
        }

    /**
     * Add a parser message listener
     * @param listener the message listener to add
     */
    public void addMessageListener(MessageListener listener){
        messageHandler.addListener(listener);
    }

    /**
     * Remove a parser message listener
     * @param listener the message listener to remove
     */
    public void removeMessageListener(MessageListener listener){
        messageHandler.removeListener(listener);
    }

    /**
     * Notify listeners after setting the message
     * @param message message to be set.
     */
    public void sendMessage(Message message){
        messageHandler.sendMessage(message);
    }
}
